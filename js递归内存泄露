内存泄露列子：

function isEven (num) {
    if (num === 0) {
        return true;
    }
    //业余草：www.xttblog.com
    if (num === 1) {
        return false;
    }
    //业余草：www.xttblog.com
   isEven(Math.abs(num) - 2);
}

console.log(isEven(1000000));

//Error：Maximum call stack size exceeded

解决方法：
1.
function isEven (num) {
    if (num === 0) {
        return true;
    }
    if (num === 1) {
        return false;
    }
    return function() {
        return isEven(Math.abs(num) - 2);
    }
};
function trampoline () {
    var value = isEven(100000000);
    while( typeof value === 'function') {
         value = value();
    }
    return value;
}
//Outputs: true
console.log(trampoline());

2.
var num = 100000000;
function trampoline () { num = Math.abs(num) -2;
   if (num === 0) {
        alert(1);return false;
    }
  
        return true;

}
//Outputs: true

while(num!=0){ trampoline() ; };  
//在js里，一个方法执行会调用了栈，而栈调用是有次数限制的，也就是不能太多连接调用，必须释放掉之前调用的才可能继续调用栈，而我们js一个方法执行调用栈，当我们
结束了该方法就释放了栈（方法return,或没有语句执行了就代表该方法结束释放了栈），所以上面的代码递归执行的方法并没有得到释放，是一直执行到num=0,而中间调用了
无数了方法，导致超出了允许调用栈的限制，所以报错了。而我们第二个方法用了return,我们利用两个return的最后一个return把上一步的执行结果给获取保存到，同时关闭了
此次方法调用的栈，所以每次while执行只执行了一个方法，也就只调用了一次栈。
